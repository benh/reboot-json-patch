import { type PartialMessage, Value, type JsonValue } from "@bufbuild/protobuf";
import {
  ApplyRequest,
  ApplyResponse,
  ChangesRequest,
  ChangesResponse,
  CreateRequest,
  CreateResponse,
  Document,
  InvalidOperation,
  Patch,
} from "@monorepo/api/dev/moment/differential/v1/document_rbt";
import { DOC_ID } from "@monorepo/common/constants";
import { Application, ExternalContext, ReaderContext, WriterContext, allow, allowIf, isAppInternal } from "@reboot-dev/reboot";
import { errors_pb } from "@reboot-dev/reboot-api";
import { applyPatch } from "fast-json-patch/index.mjs";

type Version = number;

type Materializer<State, View> = {
  // Before any state is passed to serve a reader, writer, transaction,
  // or workflow, return a materialized representation (“view”). Any already
  // materialized representations that were cached from previous calls will be
  // provided so that it doesn’t always have to be created from scratch, if possible.
  materialize: (state: State, cached?: View) => View;

  // To avoid bugs, we clone the last materialized representation before passing to
  // methods so that if either (a) the method fails or (b) we are running multiple
  // concurrently (e.g., multiple reader’s) they will all have their own.
  clone: (view: View) => View;
}

// MAIN SERVICER CLASS DEVELOPER EXTENDS.
abstract class Document_MaterializingServicer<View> {

  public authorizer() {
    return null;
  }

  abstract materializer(): Materializer<Document.State, View>;

  abstract create(
    context: WriterContext,
    state: Document.State,
    view: View,
    request: CreateRequest
  ): Promise<PartialMessage<CreateResponse>>;

  abstract apply(
    context: WriterContext,
    state: Document.State,
    view: View,
    request: ApplyRequest
  ): Promise<PartialMessage<ApplyResponse>>;

  abstract changes(
    context: ReaderContext,
    state: Document.State,
    view: View,
    request: ChangesRequest
  ): Promise<PartialMessage<ChangesResponse>>;
}

// WILL BE GENERATED BY REBOOT.
class Document_Servicer<View, Servicer extends Document_MaterializingServicer<View>> extends Document.Servicer {

  private servicer: Servicer;
  private views: { [key: string]: View };
  private materializer: Materializer<Document.State, View>;

  constructor(servicer: Servicer) {
    super();
    this.views = {};
    this.servicer = servicer;
    this.materializer = this.servicer.materializer();
  }

  public authorizer() {
    return this.servicer.authorizer();
  }

  async create(
    context: WriterContext,
    state: Document.State,
    request: CreateRequest
  ): Promise<PartialMessage<CreateResponse>> {
    // Create materialized view based on current state and any cached existing view.
    let view = this.materializer.materialize(state, this.views[context.stateId]);

    // Cache last materialized view.
    //
    // TODO: DO NOT CACHE IF WITHIN A TRANSACTION AS THAT VIEW HAS NOT YET BEEN
    // COMMITTED! ALTERNATIVELY WE COULD HAVE A SEPARATE CACHE FOR VIEWS MATERIALIZED
    // WITHIN THE TRANSACTION FOR BETTER PERFORMANCE.
    this.views[context.stateId] = view;

    // Clone view since don't want any updates to `view` during the call
    // to the method to have any impact because that would be a _side-effect_.
    view = this.materializer.clone(view);

    return await this.servicer.create(context, state, view, request);
  }

  async apply(
    context: WriterContext,
    state: Document.State,
    request: ApplyRequest
  ): Promise<PartialMessage<ApplyResponse>> {
    // Create materialized view based on current state and any cached existing view.
    let view = this.materializer.materialize(state, this.views[context.stateId]);

    // Cache last materialized view.
    //
    // TODO: DO NOT CACHE IF WITHIN A TRANSACTION AS THAT VIEW HAS NOT YET BEEN
    // COMMITTED! ALTERNATIVELY WE COULD HAVE A SEPARATE CACHE FOR VIEWS MATERIALIZED
    // WITHIN THE TRANSACTION FOR BETTER PERFORMANCE.
    this.views[context.stateId] = view;

    // Clone view since don't want any updates to `view` during the call
    // to the method to have any impact because that would be a _side-effect_.
    view = this.materializer.clone(view);

    return await this.servicer.apply(context, state, view, request);
  }

  async changes(
    context: ReaderContext,
    state: Document.State,
    request: ChangesRequest
  ): Promise<PartialMessage<ChangesResponse>> {
    // Create materialized view based on current state and any cached existing view.
    let view = this.materializer.materialize(state, this.views[context.stateId]);

    // Cache last materialized view.
    //
    // TODO: DO NOT CACHE IF WITHIN A TRANSACTION AS THAT VIEW HAS NOT YET BEEN
    // COMMITTED! ALTERNATIVELY WE COULD HAVE A SEPARATE CACHE FOR VIEWS MATERIALIZED
    // WITHIN THE TRANSACTION FOR BETTER PERFORMANCE.
    this.views[context.stateId] = view;

    // Clone view since `reader`s may run concurrently.
    view = this.materializer.clone(view);

    return await this.servicer.changes(context, state, view, request);
  }
}

// ONLY CLASS THAT DEVELOPERS HAVE TO IMPLEMENT.
class DocumentServicer extends Document_MaterializingServicer<[Version, JsonValue]> {

  public authorizer() {
    return new Document.Authorizer({
      // TODO: these are necessary when running on the cloud
      // but should lock them down!
      create: allow(),
      apply: allowIf({ all: [isAppInternal] }),
      changes: allow(),
    });
  }

  public materializer() {
    return {
      materialize: (state: Document.State, cached?: [Version, JsonValue]): [Version, JsonValue] => {
        let [version, value]: [number, JsonValue] = cached ?? [0, {}];

        if (version < state.patches.length) {
          const patches = state.patches.slice(version);

          for (const patch of patches) {
            value = applyPatch(
              value,
              [...patch.operations.map((operation) => operation.toJson())],
            ).newDocument;

            version++;
          }
        }

        return [version, value];
      },

      clone: ([version, value]: [Version, JsonValue]): [Version, JsonValue] => {
        // TODO: probably a better way to "clone" `value`!
        return [version, JSON.parse(JSON.stringify(value))];
      }
    };
  }

  async create(
    context: WriterContext,
    state: Document.State,
    [version, value]: [Version, JsonValue],
    request: CreateRequest
  ): Promise<PartialMessage<CreateResponse>> {
    return {
      value: Value.fromJson(value),
      version,
    };
  }

  async apply(
    context: WriterContext,
    state: Document.State,
    [version, value]: [Version, JsonValue],
    request: ApplyRequest
  ): Promise<PartialMessage<ApplyResponse>> {
    if (request.version != version) {
      throw new Document.ApplyAborted(new errors_pb.FailedPrecondition());
    }

    try {
      value = applyPatch(
        value,
        [...request.operations.map((operation) => operation.toJson())],
        /* validateOperation = */ true,
        /* mutateDocument = */ false
      ).newDocument;
    } catch (error) {
      throw new Document.ApplyAborted(new InvalidOperation({
        // @ts-ignore
        message: error.message,
        // @ts-ignore
        index: error.index,
      }));
    }

    state.patches = [
      ...state.patches,
      new Patch({ operations: request.operations })
    ];

    return {};
  }

  async changes(
    context: ReaderContext,
    state: Document.State,
    [version, value]: [Version, JsonValue],
    { sinceVersion }: ChangesRequest
  ): Promise<PartialMessage<ChangesResponse>> {
    if (sinceVersion > version) {
      throw new Document.ChangesAborted(new errors_pb.InvalidArgument());
    }

    return {
      version: sinceVersion,
      patches: state.patches.slice(sinceVersion),
    };
  }
}

// WILL NOT EXIST WITH BUILT-IN ABSTRACTION, WILL BE INCORPORATED IN GENERATED CLASSES ABOVE.
class DocumentServicerHelper extends Document_Servicer<[Version, JsonValue], DocumentServicer> {
  constructor() {
    super(new DocumentServicer());
  }
}

const initialize = async (context) => {
  const document = Document.ref(DOC_ID);

  await document.idempotently().create(context);

  await document.idempotently("patch 1").apply(context, {
    version: 0,
    operations: [
      { op: "add", path: "/firstName", value: Value.fromJson("Alex") },
      { op: "add", path: "/lastName", value: Value.fromJson("Clemmer") },
    ],
  });

  await document.idempotently("patch 2").apply(context, {
    version: 1,
    operations: [
      {
        op: "add",
        path: "/contactDetails",
        value: Value.fromJson({ number: "206-123-4567" })
      }
    ],
  });

  const { version, patches } = await document.changes(context);

  console.log(`Patches from version ${version} to ${patches.length}:`);

  for (const patch of patches) {
    const operations = [
      ...patch.operations.map((operation) => operation.toJson())
    ];
    console.log(`${JSON.stringify(operations)}`);
  }
};


new Application({ servicers: [DocumentServicerHelper], initialize }).run();
